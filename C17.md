### Environment

- a source file, with headers and sources included via `#include`, is called _preprocessing translation unit_. After preprocessing, it is called _translation unit_
- In freestanding environment, C program executes without any benefit of an operating system (except minimal set in clause 4) and the name/type of a function is called at startup is implementation-defined
- In hosted environment
  - startup function is `main` with return type `int` and with not parameters or two named `argc`/`argv`
  ```c
  int main() {}
  int main(int argc, char *argv[]) {} // argc is non-negative, argv[0] is program name if exist <- both are modifiable
  ```
  - return of `main` is equivalent to calling `exit` with the same value if its return type is int-compatible and reach `}` is equivalent to `return 0`
- integer/double-precision promotion promote each operand to `int/double` then do the operator and truncate afterward, but the actual execution need only produce the same result, possibly omitting the promotion
  ```c
  char c1, c2;
  c1 = c1 + c2;
  ----
  float f1, f2;
  f1 = f2 + 0.2;
  ```
- rearrangement for floating-point expression is often restrict because of precision
  ```c
  double x, y, z;
  x = (x * y) * z; // != x *= y * z
  z = (x - y) + y; // != z = x
  z = x + x * y; // != z = x * (1 + y)
  y = x / 5.0; // != y = x * 0.2
  ```
- on a machine which overflows produce an explicit trap, cannot rewrite expression even with associativity
  ```c
  int a, b;
  a = a + 32760 + b + 5; // != a = a + b + 32760 + 5
  ```
- the order of execution of each operand is undefined
  ```c
  int sum;
  int *p;
  sum = sum + 10 + (*p++ = getchar()) // increment of p or getchar can occur at any point between previous and next sequence point
  ```
- trigraph sequences are replaced before any processing (usually need to enable via `-trigraphs`)
  ```c
  ??=define arraycheck(a, b) a??(b??) ??!??! b??(a??)
  â†“
  #define arraycheck(a, b) a[b] || b[a]
  ```

### Language

#### Concepts

- identifiers can belong to one of four scopes (funciton, file, block and function prototype)
  - label name scope is only function scope
- only enumeration constant has scope right after of its defining enumerator, others have scope after the completion of its declarator
  ```c
  enum state {
    PENDING = 0,
    FAILED = PENDING, // can use `pending` right after
  };
  ```
- if an identifier with `extern` in the scope which already exist that identifier, identifier keep the prior linkage
  ```c
  static int i = 10;
  extern int i; // i linkage is internal
  -----
  int i = 10;
  extern int i; // i linkage is external
  ```
- an _automatic storage duration_ object (not VLA)'s lifetime from entry into the object (`goto` into middle of block) until exection of that blocks end in anyway (`goto`). For VLA, its lifetime is available only if passing through the declaration
  ```c
  int main()
  {
    goto test;
    {
      int x = 1;
    test:
      printf("%d", x); // work
    }
  }
  ```
- a non-lvalue expression with struct or union type, its member with array-type refer to an object which has temporary lifetime
  ```c
  struct X { char a[8]; };
  struct Y { char a; };
  struct X getX(void) {
    struct X result = { "world" };
    return result;
  }
  struct Y getY() {
    struct Y result = { 1 };
    return result;
  }
  int main() {
    char *i = getX().a; // work
    char *j = &getY().a; // not work
  }
  ```
- _scalar types_ = _arithmetic types_ + _pointer types_
  - _arithemetic types_ = _integer types_ + _floating types_
  - _integer types_ = char types + signed/unsigned integer types + enumerated types
  - _floating types_ = real floating types + complex types
- _trap representation_ don't present values of the object type and not applied for struct or union (even any of their members can be trap representation)
  for example a C implementation take take non {0, 1} values to be trap representation for `_Bool`
- most of recenlt C compilers only support two's complement
- alignment of a struct object is the strictest (largest) alignment from its members and valid alignment values are a non-negative integral power of two
